# Residue Cross-Mapping and Analysis Toolkit

## Overview

This toolkit provides a suite of Python scripts designed to facilitate the mapping and analysis of residues between a reference protein structure and a homologous structure (e.g., a homology model or an AlphaFold2 prediction). This is particularly useful when the homologous structure may contain insertions, deletions, or point mutations relative to the reference.

The primary goal is to allow users to identify residues of interest in a reference structure and accurately find their equivalents in a potentially non-identical target structure, and subsequently analyze their local environment.

## Problem Solved

When working with multiple protein structures, especially a canonical reference and a computationally derived model:
*   Sequence alignments can show equivalencies, but translating these back to specific PDB residue numbers, especially with gaps, can be tedious.
*   Identifying which residue in your *model* corresponds to a known functional residue in the *reference* is crucial for analysis.
*   Once key residues are mapped, understanding their structural context (e.g., nearby residues) in the new model is often the next step.

These scripts automate these processes.

## Scripts Included

1.  **`create_residue_map.py`**:
    *   **Purpose**: Aligns the protein sequences extracted from a reference PDB file and an input (homologous) PDB file.
    *   **Output**: Generates a residue map file (e.g., `.rmp`). This tab-separated file lists corresponding pairs of residues: `RefResName  RefResNum  InputResNum`.
    *   **Key Feature**: Handles differences in residue numbering and accounts for insertions/deletions based on the sequence alignment.

2.  **`rmpx.py`** (Residue Map Extractor):
    *   **Purpose**: Takes a residue map file (generated by `create_residue_map.py`) and a list of *reference* residue numbers.
    *   **Output**: For each provided reference residue number, it outputs the corresponding residue name (from reference) and residue number in the *input* (homologous) structure.
    *   **Use Case**: If you know residue "LYS 123" is important in your reference, this script tells you which residue (e.g., "LYS 125" or even "ALA 125" if mutated) it corresponds to in your model.

3.  **`find_nearby_residues.py`**:
    *   **Purpose**: A PyMOL script to identify all residues within specified distance cutoffs from a given selection (e.g., a ligand, a specific residue, or a set of residues).
    *   **Output**: Text files detailing the nearby residues (Chain, Residue ID, Residue Name) for each specified distance.
    *   **Use Case**: After mapping a key residue to your model, use this script to find its interacting partners or local environment in the model.

## Workflow Example

1.  **Generate a Residue Map**:
    You have `reference.pdb` (e.g., a crystal structure) and `model.pdb` (e.g., an AlphaFold prediction).
    ```bash
    python create_residue_map.py -r reference.pdb -i model.pdb -o ref_to_model.rmp
    ```
    This creates `ref_to_model.rmp` mapping residues from `reference.pdb` to `model.pdb`.

2.  **Find Corresponding Residues**:
    You are interested in residues 15, 42, and 103 from `reference.pdb`. Create a file `my_ref_residues.txt` with:
    ```
    15
    42
    103
    ```
    Then run:
    ```bash
    python rmpx.py -f my_ref_residues.txt -m ref_to_model.rmp -o model_equivalents.txt
    ```
    `model_equivalents.txt` will now list the residues in `model.pdb` that correspond to 15, 42, and 103 from the reference.

3.  **Analyze Local Environment in the Model**:
    Let's say `rmpx.py` showed that reference residue 42 (e.g., LEU 42) corresponds to `LEU 55` in `model.pdb`. You want to find residues near `LEU 55` in `model.pdb`.
    *   Modify `find_nearby_residues.py` to target `model.pdb` and the selection `resn LEU and resi 55` (or however you define the selection in PyMOL).
    *   Run `find_nearby_residues.py` from within PyMOL:
        ```pymol
        run find_nearby_residues.py
        ```
    *   This will generate an output file listing residues near LEU 55 in your model.

## Prerequisites

*   **Python 3.x**
*   **Biopython**: Required by `create_residue_map.py` for PDB parsing and sequence alignment.
    ```bash
    pip install biopython
    ```
*   **PyMOL**: Required to run `find_nearby_residues.py`.

## Usage

Each script has its own command-line arguments. Use the `-h` or `--help` flag for detailed options:

```bash
python create_residue_map.py --help
python rmpx.py --help
```
For `find_nearby_residues.py`, configure the `targets` and `distances_A` variables directly within the script, then run it from the PyMOL command line.

### File Formats

*   **Residue Map File (`.rmp`)**:
    *   Tab-separated values.
    *   Header: `#RefResName\tRefResNum\tInputResNum`
    *   Example line: `ILE\t339\t357` (meaning Isoleucine 339 in the reference maps to residue 357 in the input structure).
*   **Input Residue File (for `rmpx.py -f`)**:
    *   Plain text file, one reference residue number per line.
    *   Comments (lines starting with `#`) and residue names on the line are ignored (only the first number found is taken).
    *   Example:
        ```
        # Active Site
        339
        LYS 343  # catalytic
        380
        ```

## Current Status & Notes

*   The scripts generally work well for their intended purposes.
*   **Manual Step for Overlapping Regions**: The `create_residue_map.py` script aligns full sequences from the PDB files. If you are interested in mapping only a specific domain or an overlapping region that requires precise structural alignment beyond simple sequence alignment, you might need to manually prepare PDB files that only contain these specific regions of interest before running `create_residue_map.py`.
*   **Robustness**: While the scripts seem to function correctly ("zero-shot"), thorough testing across a wide variety of edge cases (e.g., very divergent structures, non-standard residues not handled by Biopython's default dictionaries) is ongoing. The `create_residue_map.py` script includes several fallbacks for three-to-one amino acid code conversion to enhance robustness.

## Future Considerations

*   Integration of structural alignment for map creation as an alternative or supplement to sequence alignment.
*   More sophisticated handling of ambiguous mappings or regions with low alignment confidence.
*   Direct PyMOL integration for `rmpx.py` to select mapped residues.

---
*This README was generated based on the provided scripts and user input.*
